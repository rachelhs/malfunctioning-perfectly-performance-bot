from flask import Flask, jsonify, render_template, request
import webbrowser
import time
import json

# imports the Google Cloud client library
from google.cloud import language
from google.cloud.language import enums
from google.cloud.language import types
import speech_recognition as sr
import os

# open ai library
import openai
from decouple import config

# imports text to speech library
from gtts import gTTS
# imports mp3 player library
import playsound

app = Flask(__name__)

# get data from json file
with open("data.json") as jsonFile:
    data = json.load(jsonFile)
    jsonFile.close()

# generates a response with gtp-3 api
def gtp3_response(question):
    # load your API key from an environment variable or secret management service
    openai.api_key = config("OPENAI_API_KEY")
    # load prompts and settings from data stored in json file
    prompt = data[question]['api_prompt']
    temperature = data[question]['temperature']
    presence_penalty = data[question]['presence_penalty']
    frequency_penalty = data[question]['frequency_penalty']
    stop_sequences = data[question]['stop_sequences']

    # access Open AI GPT-3 API
    response_object = openai.Completion.create(engine="davinci", prompt=prompt, max_tokens=150, temperature=temperature, top_p=1, frequency_penalty=frequency_penalty, best_of=1, presence_penalty=presence_penalty, stop=stop_sequences)
    # single out the AI's response to the prompt
    response = response_object.choices[0].text

    # remove trailing half sentences
    # find the last instance of a punctuation mark in the text
    last_punctuation_mark = max(response.rfind(i) for i in "?.!")

    # if no punctuation is found at all, keep all of the text
    if (last_punctuation_mark == -1):
        response_full_sentences = response

    # otherwise keep the text up until the last punctuation mark
    else:
        response_full_sentences = response[0:(last_punctuation_mark+1)]
    
    return response_full_sentences

# listens for audience question
def recognise_question_from_speech():
    # obtain audio from the microphone
    r = sr.Recognizer()
    with sr.Microphone() as source:
        #https://github.com/Uberi/speech_recognition/blob/master/reference/library-reference.rst
        #timeout is how long it will listen for if nothing is detected (None means no limit)
        print('listening')
        timeout = None
        phrase_time_limit = None
        audio = r.listen(source, timeout, phrase_time_limit)
        print('processing')

    # recognize speech using Google speech to text
    try:
        text = u""+str(r.recognize_google(audio))
        print('Heard: {}'.format(text))
    except sr.UnknownValueError:
        text = 'unknown'
        print("Google could not understand audio")
    except sr.RequestError as e:
        text = 'unknown'
        print("Google error; {0}".format(e))

    os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = 'google-service-account/tokyo-comfort-320610-e45e3b8edd50.json'

    if ("chronically" in text) | ("chronic" in text) | ("late" in text):
        result = 'chronically_late'
        print('chronically_late')
    elif ("study" in text):
        result = 'help_study'
        print('help_study')
    elif ("do you take ADHD medication" in text) | ("meth" in text):
        result = 'adhd_medication'
        print('adhd_medication')
    elif("feel like" in text) | ("first went on" in text):
        result = 'first_feel_like_medication'
        print('first_feel_like_medication')
    elif("what is it like" in text) | ("to have ADHD" in text):
        result = 'what_is_it_like'
        print('what_is_it_like')
    elif("goodbye" in text):
        result = 'end'
        print('end')
    else:
        result = 'unknown'
    
    return text, result

import random

# selects an answer at random from the bank of answers
def random_response_from_bank(question):

    real_responses = data[question]['real_responses']
    response = real_responses[str((random.randrange(len(real_responses)))+1)]

    return response

# randomly select whether the response comes from a bank of answers or automatically generated ones
def choose_response(question):
    if (question == 'unknown'):
        response = random_response_from_bank(question)
        return response
    else:
        random_choice = random.randrange(2)
        if (random_choice == 0):
            print("answer from bank of questions")
            response = random_response_from_bank(question)
            return response
        else:
            print("answer generated by gpt-3")
            response = gtp3_response(question)
            return response

@app.route('/_text_to_speech', methods = ['GET', 'POST'])
def text_to_speech():
    bot_response = request.form.get('bot_response')
    # fallback response in case gtp-3 generates blank text
    if (len(bot_response) < 5):
        bot_response = "some sort of don't know response"
    language = 'en'
    audio = gTTS(text=bot_response, lang=language, slow=False)
    # save audio
    audio.save("response.mp3")
    # play audio
    playsound.playsound("/Users/rachel/Documents/Malfunctioning-Perfectly/malfunctioning-perfectly-live-bot/response.mp3", True)
    return jsonify('finished')

@app.route('/_stuff', methods = ['GET'])
def stuff():
    audience_speech, audience_question = recognise_question_from_speech()
    bot_response = choose_response(audience_question)
    values = {
        "result": audience_speech,
        "botResponse": bot_response
    }
    return jsonify(values)

@app.route('/')
def index():
   
    return render_template('index.html')
    
if __name__ == '__main__':
    app.run()